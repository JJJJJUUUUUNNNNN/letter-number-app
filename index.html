<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Letter-Number Linker (Web Prototype)</title>
<style>
  body { margin:0; font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#0a0f0a; color:#e9ffe9;}
  header { padding:10px 14px; position:sticky; top:0; background:#0f1a0f; border-bottom:1px solid #1f3d1f; z-index:10;}
  button { padding:10px 14px; margin-right:8px; border:0; border-radius:8px; background:#1f5d1f; color:#fff; font-weight:600;}
  button:disabled{opacity:.5}
  .wrap { position:relative; }
  video, canvas#overlay { width:100vw; height:56.25vw; max-height:70vh; object-fit:contain; background:#000; display:block; }
  #list { padding:10px 14px; }
  table { width:100%; border-collapse:collapse; }
  th, td { text-align:left; padding:8px; border-bottom:1px solid #1f3d1f; }
  .note { color:#a7e3a7; font-size:.9em; }
  .chip { padding:2px 6px; border-radius:6px; background:#184418; font-size:.8em; }
</style>
</head>
<body>
<header>
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Pause</button>
  <button id="exportBtn" disabled>Export CSV</button>
  <span class="chip" id="fps">— fps</span>
  <span class="chip" id="status">idle</span>
  <div class="note">カメラ上にある四角(牌)とテキストを検出→英字1文字と近くの数字(2–4桁)を紐づけて表示します。</div>
</header>

<div class="wrap">
  <video id="video" playsinline muted></video>
  <canvas id="overlay"></canvas>
  <!-- 非表示のフレーム取得用 -->
  <canvas id="off" style="display:none;"></canvas>
</div>

<section id="list">
  <h3>検出一覧</h3>
  <table>
    <thead><tr><th>#</th><th>Letter</th><th>Number</th><th>信頼度</th><th>更新</th></tr></thead>
    <tbody id="rows"></tbody>
  </table>
</section>

<!-- OpenCV.js & Tesseract.js（CDN） -->
<script async src="https://docs.opencv.org/4.x/opencv.js" ></script>
<script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<script>
(() => {
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const off = document.getElementById('off');
  const ctx = overlay.getContext('2d');
  const rows = document.getElementById('rows');
  const fpsSpan = document.getElementById('fps');
  const statusSpan = document.getElementById('status');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const exportBtn = document.getElementById('exportBtn');

  let running = false;
  let lastTime = performance.now();
  let acc = 0, frames = 0;

  // タイル管理（矩形の中心近傍でID同定）
  const tiles = new Map(); // id -> {bbox, letter, number, confL, confN, last}

  const tesseract = Tesseract.createWorker({
    logger: m => {} // 進捗は表示しない
  });

  // 近傍距離
  const dist = (a,b) => Math.hypot(a.x - b.x, a.y - b.y);

  // CSV書き出し
  function exportCSV() {
    const lines = [["id","letter","number","confLetter","confNumber","updatedAt"]];
    for (const [id, t] of tiles.entries()) {
      lines.push([id, t.letter||"", t.number||"", t.confL?.toFixed(2)||"", t.confN?.toFixed(2)||"", new Date(t.last).toLocaleString()]);
    }
    const csv = lines.map(r => r.map(v => `"${(v??"").toString().replace(/"/g,'""')}"`).join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"pairs.csv"});
    a.click(); URL.revokeObjectURL(url);
  }

  // テーブル更新
  function renderList() {
    const arr = [...tiles.entries()].sort((a,b)=> (a[1].letter||"") .localeCompare(b[1].letter||""));
    rows.innerHTML = arr.map(([id,t],i)=>`
      <tr>
        <td>${i+1}</td>
        <td>${t.letter ?? ""}</td>
        <td>${t.number ?? ""}</td>
        <td>${(t.confL??0).toFixed(2)} / ${(t.confN??0).toFixed(2)}</td>
        <td>${new Date(t.last).toLocaleTimeString()}</td>
      </tr>
    `).join("");
    exportBtn.disabled = tiles.size===0;
  }

  // OpenCVで四角候補（牌）を検出
  function detectRectangles(mat) {
    const gray = new cv.Mat();
    const blur = new cv.Mat();
    const edges = new cv.Mat();
    cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    cv.Canny(blur, edges, 60, 150);

    const contours = new cv.MatVector();
    const hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    const rects = [];
    for (let i=0;i<contours.size();i++) {
      const cnt = contours.get(i);
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, 0.03 * peri, true);
      if (approx.rows === 4 && cv.contourArea(approx) > 500) {
        const r = cv.boundingRect(approx);
        // ほぼ正方形だけ採用（比 0.6〜1.4）
        const ar = r.width / r.height;
        if (ar>0.6 && ar<1.4) {
          rects.push({x:r.x, y:r.y, w:r.width, h:r.height, cx:r.x + r.width/2, cy:r.y + r.height/2});
        }
      }
      cnt.delete(); approx.delete();
    }
    gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    return rects;
  }

  // OCR（フレーム全体を一度だけ）
  async function ocrFullFrame(canvas) {
    const { data: { words } } = await Tesseract.recognize(canvas, 'eng', {
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    });
    // words: [{text, bbox:{x0,y0,x1,y1}, confidence}]
    return words.map(w => ({
      text: (w.text||"").trim(),
      box: {x:w.bbox.x0, y:w.bbox.y0, w:w.bbox.x1-w.bbox.x0, h:w.bbox.y1-w.bbox.y0, cx:(w.bbox.x0+w.bbox.x1)/2, cy:(w.bbox.y0+w.bbox.y1)/2},
      conf: w.confidence ?? 0
    }));
  }

  // 牌とテキストを紐づけ
  function associate(rects, texts) {
    // 英字/数字に分ける
    const letters = texts.filter(t => /^[A-Z]$/.test(t.text));
    const numbers = texts.filter(t => /^\d{2,4}$/.test(t.text));

    const results = [];
    for (const r of rects) {
      // 牌“内側”の最も近い英字
      const insideLetters = letters.filter(t => (
        t.box.cx >= r.x+4 && t.box.cx <= r.x + r.w - 4 &&
        t.box.cy >= r.y+4 && t.box.cy <= r.y + r.h - 4
      ));
      let L = null;
      if (insideLetters.length) {
        insideLetters.sort((a,b)=> dist({x:a.box.cx,y:a.box.cy},{x:r.cx,y:r.cy}) - dist({x:b.box.cx,y:b.box.cy},{x:r.cx,y:r.cy}));
        L = insideLetters[0];
      }
      // 牌“周辺”の数字（中心から半径 = 長辺の1.2倍以内）
      const rad = Math.max(r.w, r.h) * 1.2;
      const nearNumbers = numbers.filter(t => dist({x:t.box.cx,y:t.box.cy},{x:r.cx,y:r.cy}) < rad);
      let N = null;
      if (nearNumbers.length) {
        // 中心に最も近いもの
        nearNumbers.sort((a,b)=> dist({x:a.box.cx,y:a.box.cy},{x:r.cx,y:r.cy}) - dist({x:b.box.cx,y:b.box.cy},{x:r.cx,y:r.cy}));
        N = nearNumbers[0];
      }
      if (L || N) results.push({rect:r, L, N});
    }
    return results;
  }

  // 可視化
  function draw(rects, pairs) {
    ctx.clearRect(0,0,overlay.width, overlay.height);
    // 四角
    ctx.lineWidth = 2; ctx.strokeStyle = "#00ff88"; ctx.font = "14px SFMono-Regular, Menlo, monospace"; ctx.fillStyle="#00ff88";
    rects.forEach(r => {
      ctx.strokeRect(r.x, r.y, r.w, r.h);
    });
    // ラベル
    pairs.forEach(p => {
      const label = `[${p.L?.text ?? "?"}]=${p.N?.text ?? "???"}`;
      ctx.fillText(label, p.rect.x, p.rect.y - 4);
    });
  }

  // 牌IDの更新（矩形中心の近傍でマッチ）
  function updateTiles(pairs) {
    const now = Date.now();
    for (const p of pairs) {
      // 既存で最も近いID
      let bestId = null, bestD = 99999;
      for (const [id,t] of tiles) {
        const d = dist({x:t.bbox.cx,y:t.bbox.cy},{x:p.rect.cx,y:p.rect.cy});
        if (d < bestD) { bestD = d; bestId = id; }
      }
      const isNew = bestD > Math.max(p.rect.w, p.rect.h) * 0.8;
      const id = isNew ? crypto.randomUUID() : bestId;
      const prev = tiles.get(id) || {};
      tiles.set(id, {
        bbox: p.rect,
        letter: p.L?.text ?? prev.letter ?? null,
        number: p.N?.text ?? prev.number ?? null,
        confL: p.L?.conf ?? prev.confL ?? 0,
        confN: p.N?.conf ?? prev.confN ?? 0,
        last: now
      });
    }
    // 古いものをクリーン（10秒見えない）
    for (const [id,t] of [...tiles]) {
      if (now - t.last > 10000) tiles.delete(id);
    }
    renderList();
  }

  // メインループ
  async function loop() {
    if (!running) return;
    const t0 = performance.now();

    // Canvasサイズを動画に合わせる
    const w = video.videoWidth, h = video.videoHeight;
    if (!w || !h) { requestAnimationFrame(loop); return; }
    overlay.width = off.width = w;
    overlay.height = off.height = h;
    const octx = off.getContext('2d');
    octx.drawImage(video, 0, 0, w, h);

    // OpenCV: 画像→Mat
    const frame = cv.imread(off);
    const rects = detectRectangles(frame); // 牌候補
    frame.delete();

    // OCR（Tesseract）
    const texts = await ocrFullFrame(off);

    const pairs = associate(rects, texts);
    draw(rects, pairs);
    updateTiles(pairs);

    // fps
    const t1 = performance.now();
    frames++; acc += (t1 - lastTime); lastTime = t1;
    if (acc > 1000) { fpsSpan.textContent = `${frames} fps`; frames = 0; acc = 0; }

    statusSpan.textContent = `rects:${rects.length}  words:${texts.length}`;
    // 負荷軽減：600ms間隔
    setTimeout(()=> requestAnimationFrame(loop), 600);
  }

  // 開始/停止
  async function start() {
    if (running) return;
    startBtn.disabled = true;
    statusSpan.textContent = "initializing…";
    // Tesseract worker起動（初回のみ）
    if (!tesseract.__loaded) { await tesseract.load(); await tesseract.loadLanguage('eng'); await tesseract.initialize('eng'); tesseract.__loaded = true; }

    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    await video.play();
    running = true;
    stopBtn.disabled = false; exportBtn.disabled = false;
    loop();
  }

  function stop() {
    running = false;
    (video.srcObject?.getTracks()||[]).forEach(t=>t.stop());
    startBtn.disabled = false; stopBtn.disabled = true;
    statusSpan.textContent = "paused";
  }

  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);
  exportBtn.addEventListener('click', exportCSV);

})();
</script>
</body>
</html>
